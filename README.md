About this Project
In this project, a research repository is created that includes the practice code examples and design patterns with coding examples in python.

Repository Structure
I have created a public repository with the name pythonProject.This repository contains two folders named practice code and Design Patterns. 
In the practice code folder, I have added all the coding examples with comments that I have carried out during my coding journey with Python. The topics that I learnt in this journey includes: Data types, Expressions and statements, Loops and containers, Functions, Manipulating strings, Data Validation and exception handling and OOP concepts. 
The second folder is about the design patterns and principles. I did an internet search to know about the design patterns and then analysis of these design principles. Then I tried to integrate my research with practice codes. I have used comments in all of the python programs to have a better understanding of the concepts.

Design Patterns in Python
Design patterns are reusable solutions to common software design problems. They provide a structured approach to solving problems that arise in object-oriented programming. Design patterns are not specific to any programming language, but they can be implemented in different languages with varying levels of complexity. In this tutorial, we will discuss several design patterns and how they can be implemented in Python, a popular object-oriented programming language. By understanding and utilizing design patterns, programmers can write more efficient, maintainable, and flexible code.
The Singleton Pattern
The Factory Pattern
The Observer Pattern
The Decorator Pattern
The Command Pattern
The Adapter Pattern
The Facade Pattern
The Template Method Pattern
The Iterator Pattern


Design Principles
SOLID Design Principles stands for:
Single Responsibility Principle: A Class should only have one responsibility.
Open/Close Principle: A software module should be open for extension but closed for modification.
Liskov Substitution Principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.
Interface Segregation Principle: Clients should not be forced to depend upon the interfaces that they do not use.
Dependency Inversion Principle: Program to an interface, not to an implementation.
